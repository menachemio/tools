#!/bin/bash
# Cleanup Utility — modular system cleanup with YAML config support
# Usage: cleanup [--dry-run] [--auto] [--config <file>] [--update]

set -euo pipefail

# Resolve paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$(dirname "$SCRIPT_DIR")/lib/cleanup"

# Source modules
source "$LIB_DIR/common.sh"
source "$LIB_DIR/config.sh"
source "$LIB_DIR/vscode.sh"
source "$LIB_DIR/nodejs.sh"
source "$LIB_DIR/system.sh"
source "$LIB_DIR/dev-tools.sh"
source "$LIB_DIR/updates.sh"

# CLI flags
CONFIG_FILE=""
RUN_UPDATES=false

show_help() {
    cat << 'EOF'
Cleanup Utility — intelligent system cleaning

Usage:
  cleanup                          Interactive cleanup with prompts
  cleanup -d, --dry-run            Preview what would be cleaned
  cleanup -a, --auto               Auto-clean safe targets (no prompts)
  cleanup -c, --config <file>      Use YAML configuration file
  cleanup -u, --update             Also run system/tool updates
  cleanup -v, --verbose            Show detailed output
  cleanup -h, --help               Show this help

Flags can be combined:
  cleanup --dry-run --update  Preview cleanup + updates
  cleanup --auto --config ~/.config/tools/cleanup.yaml

Config lookup:
  1. --config <file>           Explicit path
  2. $CLEANUP_CONFIG            Environment variable
  3. ~/.config/tools/cleanup.yaml  Default location
EOF
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run|-d)   DRY_RUN=true ;;
            --auto|-a)      AUTO_MODE=true ;;
            --verbose|-v)   VERBOSE=true ;;
            --update|-u)    RUN_UPDATES=true ;;
            --config|-c)
                shift
                CONFIG_FILE="${1:-}"
                [[ -z "$CONFIG_FILE" ]] && { log_error "Missing config file path"; exit 1; }
                ;;
            --help|-h|help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
        shift
    done
}

main() {
    parse_args "$@"

    echo -e "${GREEN}=== System Cleanup ===${NC}"
    [[ "$DRY_RUN" == "true" ]] && echo -e "${YELLOW}DRY-RUN MODE — no changes will be made${NC}"
    [[ "$AUTO_MODE" == "true" ]] && echo -e "${YELLOW}AUTO MODE — safe targets cleaned without prompts${NC}"
    echo

    # Load configuration
    if [[ -n "$CONFIG_FILE" ]]; then
        load_cleanup_config "$CONFIG_FILE" || exit 1
    elif [[ -n "${CLEANUP_CONFIG:-}" && -f "$CLEANUP_CONFIG" ]]; then
        load_cleanup_config "$CLEANUP_CONFIG"
    elif [[ -f "$HOME/.config/tools/cleanup.yaml" ]]; then
        load_cleanup_config "$HOME/.config/tools/cleanup.yaml"
    else
        init_cleanup_defaults
    fi

    # Disk usage before
    local INITIAL_USAGE
    INITIAL_USAGE=$(df / | awk 'NR==2 {print $3}')
    log_info "Current disk usage:"
    df -h /
    echo

    # Run cleanup modules based on config
    if target_enabled "dev_tools"; then
        clean_cached_installers
        echo
    fi

    if target_enabled "vscode"; then
        clean_vscode_server
        echo
    fi

    if target_enabled "system"; then
        clean_system_logs
        echo
    fi

    if target_enabled "nodejs"; then
        clean_npm_cache
        echo
        clean_package_caches
        echo
        clean_orphaned_node_modules
        echo
    fi

    if target_enabled "wrangler"; then
        clean_wrangler
        echo
    fi

    if target_enabled "dev_tools"; then
        clean_dev_tools
        echo
    fi

    if target_enabled "docker"; then
        clean_docker
        echo
    fi

    if target_enabled "system"; then
        clean_temp_files
        echo
        clean_user_logs
        echo
    fi

    # System updates (opt-in)
    if [[ "$RUN_UPDATES" == "true" ]]; then
        echo -e "${GREEN}=== System Updates ===${NC}"
        echo
        run_system_updates
        echo
    fi

    # Large file scan
    if [[ "$DRY_RUN" != "true" ]]; then
        if confirm_action "Search for large files?"; then
            log_info "Looking for large files in \$HOME..."
            echo -e "\n${YELLOW}Top 10 largest files:${NC}"
            find "$HOME" -type f -size +100M -exec du -h {} + 2>/dev/null | sort -rh | head -10
            echo -e "\n${YELLOW}Large directories:${NC}"
            du -h --max-depth=2 "$HOME" 2>/dev/null | sort -rh | head -15
        fi
    fi

    # Summary
    local FINAL_USAGE
    FINAL_USAGE=$(df / | awk 'NR==2 {print $3}')
    local FREED_KB=$((INITIAL_USAGE - FINAL_USAGE))

    echo
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${GREEN}=== Dry-Run Complete ===${NC}"
        log_info "No changes were made."
    elif [[ $FREED_KB -gt 0 ]]; then
        local FREED_MB=$((FREED_KB / 1024))
        echo -e "${GREEN}=== Cleanup Complete ===${NC}"
        log_success "Freed approximately ${FREED_MB}MB of disk space"
    else
        echo -e "${GREEN}=== Cleanup Complete ===${NC}"
        log_info "No significant space was freed"
    fi

    echo -e "\n${BLUE}Final disk usage:${NC}"
    df -h /
}

# Safety check
if [[ "$EUID" -eq 0 && "$HOME" != "/root" ]]; then
    log_warning "Running as root but HOME is not /root. Be careful!"
fi

main "$@"
