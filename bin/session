#!/usr/bin/env bash
# Session Manager - YAML-based tmux session management with subsessions
# Usage: session [session-name] [subsession-name] [options]

set -eo pipefail

# Resolve tools root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TOOLS_DIR="$(dirname "$SCRIPT_DIR")"
LIB_DIR="$TOOLS_DIR/lib"

# Source core functionality
source "$LIB_DIR/session/core.sh"

# Global variables
SUBSESSION_NAME=""
HEADLESS_MODE=false
ACTION=""
INSTALL_TARGET=""
REMOVE_TARGET=""

# Help message
show_help() {
    cat << 'EOF'
Session Manager - YAML-based tmux session management

Usage:
  <session-name>                             Start/attach to session
  <session-name> --headless                  Start session in background
  <session-name> <subsession>               Start/attach to subsession
  <session-name> <subsession> --headless    Start subsession in background
  <session-name> stop                        Stop main session (keep subsessions)
  <session-name> <subsession> stop          Stop specific subsession
  <session-name> kill                        Kill all sessions
  <session-name> status                      Show session status
  <session-name> restart                     Restart session
  <session-name> restart <subsession>       Restart subsession

  session install <config.yaml>      Register project as a command

Global commands:
  session list                       List all installed session wrappers
  session remove <name>              Remove an installed session wrapper
  session status-all                 Show status of all installed sessions
  session kill-all                   Kill all installed sessions
  session cleanup                    Remove wrappers with missing configs

Options:
  --headless            Start session in background (no attach)
  --verbose, -v         Enable verbose/debug output
  --help, -h            Show this help message

Flags can be combined, e.g.: session myproject --verbose --headless

Config lookup order:
  1. ./<session-name>.session.yaml
  2. ./.session.yaml
  3. ~/.config/tools/sessions/<session-name>.yaml

Pane types:
  command   - Run or pre-fill a shell command
  subsession - Attach to a managed subsession
EOF
}

# Install a session config as a named command in ~/.local/bin
install_session_command() {
    local config_file="$1"
    local install_dir="$HOME/.local/bin"

    if [[ ! -f "$config_file" ]]; then
        die "Config file not found: $config_file"
    fi

    # Resolve to absolute path
    local abs_config
    abs_config="$(cd "$(dirname "$config_file")" && pwd)/$(basename "$config_file")"

    # Parse the YAML to get the session name
    source "$LIB_DIR/common/yaml-parser.sh"
    if ! parse_yaml "$abs_config"; then
        die "Failed to parse YAML: $abs_config"
    fi

    local name
    name=$(yaml_get "name")
    if [[ -z "$name" ]]; then
        die "No 'name' field found in $abs_config"
    fi

    mkdir -p "$install_dir"

    local wrapper="$install_dir/$name"
    local session_bin="$TOOLS_DIR/bin/session"

    cat > "$wrapper" << EOF
#!/usr/bin/env bash
# tools-session-wrapper: $name
SESSION_CONFIG_FILE="$abs_config"
export SESSION_CONFIG_FILE
exec "$session_bin" "\$@"
EOF
    chmod +x "$wrapper"

    echo "Installed '$name' -> $wrapper"
    echo "  Config: $abs_config"
    echo "  Usage:  $name [subsession] [--headless|status|stop|kill|restart]"
}

# Discover all installed session wrappers
# Outputs "name\twrapper_path\tconfig_path" lines (TAB-delimited)
_discover_wrappers() {
    local install_dir="$HOME/.local/bin"
    [[ -d "$install_dir" ]] || return 0
    local wrapper line name config
    for wrapper in "$install_dir"/*; do
        [[ -f "$wrapper" ]] || continue
        grep -q "# tools-session-wrapper:" "$wrapper" 2>/dev/null || continue
        line=$(grep "# tools-session-wrapper:" "$wrapper")
        name="${line##*# tools-session-wrapper: }"
        name="${name%% *}"
        line=$(grep 'SESSION_CONFIG_FILE="' "$wrapper")
        config="${line#*SESSION_CONFIG_FILE=\"}"
        config="${config%%\"*}"
        printf '%s\t%s\t%s\n' "$name" "$wrapper" "$config"
    done
}

# List all installed session wrappers
cmd_list() {
    local found=false
    printf "%-20s %-50s %s\n" "NAME" "CONFIG" "STATUS"
    printf "%-20s %-50s %s\n" "----" "------" "------"
    while IFS=$'\t' read -r name wrapper config; do
        local status="ok"
        [[ ! -f "$config" ]] && status="missing config"
        printf "%-20s %-50s %s\n" "$name" "$config" "$status"
        found=true
    done < <(_discover_wrappers)
    $found || echo "No installed sessions found."
}

# Remove a named session wrapper
cmd_remove() {
    local target="$1"
    while IFS=$'\t' read -r name wrapper config; do
        if [[ "$name" == "$target" ]]; then
            if tmux has-session -t "$name" 2>/dev/null; then
                echo "Warning: session '$name' is currently running" >&2
            fi
            rm "$wrapper"
            echo "Removed '$name' ($wrapper)"
            return 0
        fi
    done < <(_discover_wrappers)
    echo "Warning: no wrapper found for '$target'" >&2
    return 1
}

# Show status for all installed sessions
cmd_status_all() {
    local found=false
    while IFS=$'\t' read -r name wrapper config; do
        echo "=== $name ==="
        "$wrapper" status 2>&1 || true
        echo
        found=true
    done < <(_discover_wrappers)
    $found || echo "No installed sessions found."
}

# Kill all installed sessions (with confirmation)
cmd_kill_all() {
    local wrappers
    wrappers=$(_discover_wrappers)
    [[ -z "$wrappers" ]] && { echo "No installed sessions found."; return 0; }

    echo "This will kill ALL installed sessions:"
    while IFS=$'\t' read -r name wrapper config; do
        echo "  - $name"
    done <<< "$wrappers"

    read -r -p "Continue? [y/N] " confirm
    [[ "$confirm" =~ ^[Yy]$ ]] || { echo "Aborted."; return 0; }

    while IFS=$'\t' read -r name wrapper config; do
        echo "Killing $name..."
        "$wrapper" kill 2>&1 || true
    done <<< "$wrappers"
    echo "Done."
}

# Remove wrappers whose config no longer exists
cmd_cleanup() {
    local cleaned=0
    while IFS=$'\t' read -r name wrapper config; do
        if [[ ! -f "$config" ]]; then
            rm "$wrapper"
            echo "Removed '$name' (config missing: $config)"
            ((cleaned++)) || true
        fi
    done < <(_discover_wrappers)
    [[ $cleaned -eq 0 ]] && echo "Nothing to clean up." || echo "Cleaned $cleaned wrapper(s)."
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            help|--help|-h)
                show_help
                exit 0
                ;;
            --headless)
                HEADLESS_MODE=true
                ;;
            --verbose|-v)
                export VERBOSE=true
                ;;
            install)
                ACTION="install"
                shift
                INSTALL_TARGET="${1:-}"
                return 0
                ;;
            list|status-all|kill-all|cleanup)
                ACTION="$1"
                return 0
                ;;
            remove)
                ACTION="remove"
                shift
                REMOVE_TARGET="${1:-}"
                return 0
                ;;
            stop|kill|status|restart)
                ACTION="$1"
                ;;
            *)
                # Reject unknown flags
                if [[ "$1" == --* || "$1" == -* ]]; then
                    die "Unknown flag: $1. Try: session --help"
                fi
                # First unknown arg = session name (if not set via CONFIG_FILE env)
                # Second unknown arg = subsession name
                if [[ -z "$SESSION_NAME" && -z "${SESSION_CONFIG_FILE:-}" ]]; then
                    SESSION_NAME="$1"
                elif [[ -z "$SUBSESSION_NAME" ]]; then
                    SUBSESSION_NAME="$1"
                else
                    die "Unexpected argument: $1"
                fi
                ;;
        esac
        shift
    done

    if [[ -z "$ACTION" ]]; then
        ACTION="start"
    fi
}

# Main execution
main() {
    parse_args "$@"

    # Handle install command (no config loading needed)
    if [[ "$ACTION" == "install" ]]; then
        if [[ -z "$INSTALL_TARGET" ]]; then
            die "Usage: session install <config.yaml>"
        fi
        install_session_command "$INSTALL_TARGET"
        return 0
    fi

    # Handle global management commands (no config loading needed)
    case "$ACTION" in
        list)       cmd_list; return 0 ;;
        remove)
            [[ -z "$REMOVE_TARGET" ]] && die "Usage: session remove <name>"
            cmd_remove "$REMOVE_TARGET"; return 0 ;;
        status-all) cmd_status_all; return 0 ;;
        kill-all)   cmd_kill_all; return 0 ;;
        cleanup)    cmd_cleanup; return 0 ;;
    esac

    # Determine config file location
    local config_path=""

    if [[ -n "${SESSION_CONFIG_FILE:-}" ]]; then
        # Config path passed via environment (from installed wrapper command)
        config_path="$SESSION_CONFIG_FILE"
    else
        # Use session name to find config
        [[ -z "$SESSION_NAME" ]] && SESSION_NAME=$(basename "$PWD")

        config_path=$(find_session_config "." "$SESSION_NAME") || {
            die "No config found for '$SESSION_NAME'. Create ${SESSION_NAME}.session.yaml"
        }
    fi

    # Load configuration
    load_session_config "$config_path"

    # Generate tmux config and source once (covers all code paths)
    TIMEZONE_SCRIPT=$(create_timezone_script)
    create_tmux_config "$TIMEZONE_SCRIPT"
    tmux source-file "${TOOLS_RUNTIME_DIR}/session-tmux.conf" 2>/dev/null || true

    # Handle subsession commands
    if [[ -n "$SUBSESSION_NAME" && "$ACTION" != "restart" ]]; then
        case "$ACTION" in
            start)
                ensure_subsession "$SUBSESSION_NAME"
                if [[ "$HEADLESS_MODE" == true ]]; then
                    log "Subsession '$SUBSESSION_NAME' started in background"
                else
                    exec tmux attach-session -t "$SUBSESSION_NAME"
                fi
                ;;
            stop)    stop_subsession "$SUBSESSION_NAME" ;;
            status)  echo "Subsession $SUBSESSION_NAME: $(subsession_status "$SUBSESSION_NAME")" ;;
            kill)    stop_subsession "$SUBSESSION_NAME" ;;
            *)       die "Unknown action: $ACTION (valid: start, stop, kill, status, restart)" ;;
        esac
        return 0
    fi

    # Handle restart with optional subsession target
    if [[ "$ACTION" == "restart" && -n "$SUBSESSION_NAME" ]]; then
        restart_subsession "$SUBSESSION_NAME"
        return 0
    fi

    # Handle session-level commands
    case "$ACTION" in
        start)
            if [[ "$HEADLESS_MODE" == true ]]; then
                start_session "--headless"
            else
                start_session
            fi
            ;;
        stop)     stop_session ;;
        kill)     kill_all_sessions ;;
        status)   show_session_status ;;
        restart)
            stop_session
            sleep 2
            start_session
            ;;
        *)        die "Unknown action: $ACTION (valid: start, stop, kill, status, restart)" ;;
    esac
}

main "$@"
